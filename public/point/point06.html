<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Static Point Cloud Viewer</title>
    <style>
      /* Basic reset and full-page layout for the canvas */
      body, html {
        height: 100%;
        width: 100%;
        margin: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        overscroll-behavior: none;
        overflow: hidden;
        background-color: #f0f0f0;
        font-family: sans-serif;
      }

      /* Canvas styling to fill the available space */
      canvas {
        width: 100%;
        height: 100%;
        display: block;
      }

      /* Styling for UI containers */
      #myUiContainer, #mySaveLoadContainer, #howto-container, #debug-info {
        position: fixed;
        padding: 15px;
        background-color: rgba(255, 255, 255, 0.85);
        border-radius: 12px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        color: #333;
        font-size: 14px;
        line-height: 1.5;
        z-index: 10;
      }

      #myUiContainer {
        top: 20px;
        left: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        width: 250px;
      }

      #mySaveLoadContainer {
        bottom: 20px;
        left: 20px;
        width: 300px;
      }

      #howto-container {
        position: fixed;
        bottom: 20px;
        right: 20px;
        left: auto;
        width: 200px;
      }

      /* Simple button and textarea styling */
      .my-button {
          padding: 8px 12px;
          margin: 5px 5px 5px 0;
          background-color: #007bff;
          color: white;
          border: none;
          border-radius: 6px;
          cursor: pointer;
          font-weight: bold;
      }
      .my-button:hover {
          background-color: #0056b3;
      }

      #myPointDataTextarea {
          width: 95%;
          height: 80px;
          margin-top: 5px;
          padding: 5px;
          border: 1px solid #ccc;
          resize: vertical;
          font-family: monospace;
          font-size: 10px;
      }

      /* File Input Styling (minimal inline style used for visibility) */
      #myFileLoader {
          border: 1px solid #ccc;
          border-radius: 6px;
          padding: 5px;
          margin-top: 5px;
          background-color: #f7f7f7;
      }

      label {
          display: flex;
          align-items: center;
          gap: 8px;
          cursor: pointer;
      }
    </style>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
  </head>
  <body>
        <div id="myUiContainer">
      <h3>Settings</h3>
      <div style="display: flex; flex-direction: column;">
        <label>
          <input type="checkbox" id="myAutoRotateCheckbox" checked
                 onclick="mySetAutoRotate(this.checked)"> Auto Rotate
        </label>
      </div>

      <div class="slider-group">
        <label for="myPointSizeSlider">Point Size:</label>
        <input type="range" id="myPointSizeSlider" min="0.5" max="10" value="2" step="0.5"
                 oninput="myUpdatePointSize(event)"/>
        <span id="myPointSizeValue" class="slider-value">2.0</span>
      </div>
    </div>


        <div id="mySaveLoadContainer">
        <b>Point Cloud Data (JSON)</b>
        <div style="margin-top: 5px;">
            <button class="my-button" onclick="mySaveToTextarea()">Save Current Positions</button>
            <button class="my-button" onclick="myLoadFromTextarea()">Load from Textarea</button>
            <button class="my-button" onclick="mySaveToFile()">Download File</button>
        </div>
        <textarea id="myPointDataTextarea" placeholder="Paste JSON point data here to load..."></textarea>
        <div id="myStatusMessage" style="color: #007bff; font-weight: bold; margin-top: 5px;"></div>

        <hr style="border: 0; height: 1px; background-color: #ccc; margin: 10px 0;">

                <div id="myFileLoader">
            Load from JSON File:
            <input type="file" accept=".json" onchange="myLoadFromFile(event)" style="display: block; margin-top: 5px;">
        </div>
    </div>

        <div id="howto-container">
        <div> <b>Drag</b> to orbit the model </div>
        <div> <b>Scroll</b> to zoom </div>
        <div> <b>Mouseover</b> to highlight points </div>
    </div>
        <div id="debug-info">
      <span id="error-reason">Loading 3D scene...</span>
    </div>

        <canvas id="myFluidCanvas"></canvas>

    <script>
      // Declare Three.js global variables
      let scene, camera, renderer, myPointCloud, controls;
      
      // --- MOUSE INTERACTION (RAYCASTING) VARIABLES ---
      let myRaycaster;
      let myMousePosition = new THREE.Vector2();
      let myHighlightedPoint = null;
      let myDefaultColor = new THREE.Color(0xffffff); // Default point color (White)
      let myHighlightColor = new THREE.Color(0xff0000); // Highlight color (Red)

      // DOM Elements
      const myDebugInfo = document.getElementById('debug-info');
      const myPointDataTextarea = document.getElementById('myPointDataTextarea');
      const myStatusMessage = document.getElementById('myStatusMessage');


      /**
       * Initializes the Three.js scene.
       */
      function myInit() {
          try {
              myDebugInfo.style.display = 'block';
              myDebugInfo.querySelector('span').textContent = 'Initializing 3D scene...';

              const myCanvas = document.getElementById('myFluidCanvas');
              renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
              renderer.setSize(window.innerWidth, window.innerHeight);
              renderer.setPixelRatio(window.devicePixelRatio);

              // Scene setup
              scene = new THREE.Scene();
              scene.background = new THREE.Color(0x333333); // Dark background for contrast
              camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
              camera.position.z = 250; // A bit further back to see initial content

              // Create a dummy initial point cloud (if no data is loaded)
              myCreatePointCloud(200); // Start with a simple cube of 200 points

              // OrbitControls: Allows user to interactively move/zoom the camera
              controls = new THREE.OrbitControls(camera, renderer.domElement);
              controls.autoRotate = document.getElementById('myAutoRotateCheckbox').checked;
              controls.autoRotateSpeed = 1.0;
              controls.enableDamping = true;
              controls.dampingFactor = 0.05;

              // Initialize Raycaster for mouse interaction
              myRaycaster = new THREE.Raycaster();
              // Set raycaster to only check close points to improve performance
              myRaycaster.params.Points.threshold = 3;

              // Event Listener for Mouse Movement
              window.addEventListener('mousemove', (myEvent) => {
                  myMousePosition.x = (myEvent.clientX / window.innerWidth) * 2 - 1;
                  myMousePosition.y = -(myEvent.clientY / window.innerHeight) * 2 + 1;
              });

              // Event Listener for resize
              window.onresize = myOnWindowResize;

              myDebugInfo.style.display = 'none'; // Hide debug info once loaded successfully
              myAnimate();
          } catch (error) {
              console.error("Error during initialization:", error);
              myDebugInfo.style.display = 'block';
              myDebugInfo.querySelector('span').textContent = `Error: ${error.message}. Please refresh the page.`;
          }
      }

      /**
       * Creates or recreates the point cloud object with new data.
       * Creates a simple cube of points if no positions are provided.
       */
      function myCreatePointCloud(myPositionsArray = null) {
          // Dispose of old point cloud object
          if (myPointCloud) {
              scene.remove(myPointCloud);
              myPointCloud.geometry.dispose();
              myPointCloud.material.dispose();
          }

          let myGeometry;
          
          if (myPositionsArray) {
              // Create geometry from the loaded positions array
              myGeometry = new THREE.BufferGeometry();
              const myFloat32Array = new Float32Array(myPositionsArray);
              myGeometry.setAttribute('position', new THREE.BufferAttribute(myFloat32Array, 3));
          } else {
              // Create a default cube of random points (Fallback/Initial view)
              myGeometry = new THREE.BufferGeometry();
              const myFallbackCount = 10000;
              const myFallbackPositions = new Float32Array(myFallbackCount * 3);
              const myCubeSize = 100;
              for (let i = 0; i < myFallbackPositions.length; i += 3) {
                  myFallbackPositions[i] = (Math.random() - 0.5) * myCubeSize; 
                  myFallbackPositions[i + 1] = (Math.random() - 0.5) * myCubeSize;
                  myFallbackPositions[i + 2] = (Math.random() - 0.5) * myCubeSize;
              }
              myGeometry.setAttribute('position', new THREE.BufferAttribute(myFallbackPositions, 3));
          }


          // --- ADD VERTEX COLORS (REQUIRED FOR HIGHLIGHTING) ---
          const myVertexCount = myGeometry.attributes.position.count;
          const myColorArray = new Float32Array(myVertexCount * 3);
          // Set all points to white initially
          for (let i = 0; i < myColorArray.length; i += 3) {
              myColorArray[i] = myDefaultColor.r;
              myColorArray[i + 1] = myDefaultColor.g;
              myColorArray[i + 2] = myDefaultColor.b;
          }
          myGeometry.setAttribute('color', new THREE.BufferAttribute(myColorArray, 3));


          // Create Points Material - Use vertexColors: true
          const myPointsMaterial = new THREE.PointsMaterial({
              vertexColors: true, // IMPORTANT: Allows point colors to be changed
              size: parseFloat(document.getElementById('myPointSizeSlider').value),
              sizeAttenuation: true
          });
          myPointCloud = new THREE.Points(myGeometry, myPointsMaterial);
          scene.add(myPointCloud);

          // Reset highlighted point
          myHighlightedPoint = null;
          
          // Center the new object and adjust camera focus
          if(myPointCloud.geometry.boundingBox === null) myPointCloud.geometry.computeBoundingBox();
          const myCenter = new THREE.Vector3();
          myPointCloud.geometry.boundingBox.getCenter(myCenter);
          controls.target.copy(myCenter);
          controls.update(); 
      }


      /**
       * Updates the point cloud's geometry positions with new data.
       */
      function myUpdatePointCloudPositions(myNewPositionsArray) {
          // This function is simplified: it just creates a whole new point cloud
          // instead of trying to update an existing one of a different size.
          myCreatePointCloud(myNewPositionsArray);
          myStatusMessage.textContent = `Loaded ${myNewPositionsArray.length / 3} vertices successfully.`;
      }

      /**
       * Saves the current point cloud data to the textarea.
       */
      function mySaveToTextarea() {
          if (!myPointCloud) return;

          const myPositions = myPointCloud.geometry.attributes.position.array;
          // Convert Float32Array to standard Array for JSON
          const myPositionsArray = Array.from(myPositions);

          const mySaveData = {
              metadata: "Static Point Cloud Positions (X, Y, Z coordinates)",
              vertexCount: myPositions.length / 3,
              positions: myPositionsArray
          };

          myPointDataTextarea.value = JSON.stringify(mySaveData, null, 2); // 2 spaces for formatting
          myStatusMessage.textContent = `Saved ${myPositions.length / 3} vertices to textarea.`;
      }

      /**
       * Loads point cloud data from the textarea (the main processing logic).
       */
      function myLoadFromTextarea() {
          try {
              const myJsonString = myPointDataTextarea.value.trim();
              if (!myJsonString) {
                  myStatusMessage.textContent = 'Error: Textarea is empty.';
                  return;
              }

              const myLoadedData = JSON.parse(myJsonString);
              const myNewPositionsArray = myLoadedData.positions;

              if (!Array.isArray(myNewPositionsArray) || myNewPositionsArray.length % 3 !== 0) {
                  myStatusMessage.textContent = 'Error: Loaded data structure is invalid (positions must be an array divisible by 3).';
                  return;
              }

              myUpdatePointCloudPositions(myNewPositionsArray);

          } catch (myError) {
              myStatusMessage.textContent = `Error loading data: ${myError.message}`;
              console.error(myError);
          }
      }

      /**
       * Loads a JSON file selected by the user. (Using async/await as preferred)
       */
      async function myLoadFromFile(myEvent) {
          const myFile = myEvent.target.files[0];
          if (!myFile) {
              myStatusMessage.textContent = 'No file selected.';
              return;
          }

          myStatusMessage.textContent = `Reading file: ${myFile.name}...`;

          try {
              // Read the file content asynchronously
              const myFileText = await new Promise((resolve, reject) => {
                  const myReader = new FileReader();
                  myReader.onload = () => resolve(myReader.result);
                  myReader.onerror = () => reject(new Error('Failed to read file.'));
                  myReader.readAsText(myFile);
              });

              // 1. Put the file content into the textarea for inspection
              myPointDataTextarea.value = myFileText;

              // 2. Call the main processing function
              myLoadFromTextarea();

              // Clear file input so the same file can be loaded again
              myEvent.target.value = '';

          } catch (myError) {
              myStatusMessage.textContent = `Error reading file: ${myError.message}`;
              console.error(myError);
          }
      }

      /**
       * Downloads the current point cloud data as a JSON file.
       */
      function mySaveToFile() {
          mySaveToTextarea(); // First, generate the data in the textarea
          const myJsonString = myPointDataTextarea.value;
          const myBlob = new Blob([myJsonString], { type: 'application/json' });
          const myUrl = URL.createObjectURL(myBlob);

          // Create a temporary link element for the download
          const myLink = document.createElement('a');
          myLink.href = myUrl;
          myLink.download = `pointcloud-static-${Date.now()}.json`;

          // Programmatically click the link to trigger download
          document.body.appendChild(myLink);
          myLink.click();
          document.body.removeChild(myLink);

          myStatusMessage.textContent = 'Point Cloud downloaded as JSON file.';
          URL.revokeObjectURL(myUrl); // Clean up
      }

      // --- MOUSE HIGHLIGHTING FUNCTIONS ---

      /**
       * Highlights a point by setting its color attribute.
       */
      function myHighlightPointColor(myIndex) {
          const myColors = myPointCloud.geometry.attributes.color;
          if (!myColors) return;

          myColors.setXYZ(myIndex, myHighlightColor.r, myHighlightColor.g, myHighlightColor.b);
          myColors.needsUpdate = true;
      }

      /**
       * Restores a point's color to the default white.
       */
      function myRestorePointColor(myIndex) {
          const myColors = myPointCloud.geometry.attributes.color;

          myColors.setXYZ(myIndex, myDefaultColor.r, myDefaultColor.g, myDefaultColor.b);
          myColors.needsUpdate = true;
      }

      /**
       * Uses Raycasting to detect if the mouse is over a point and highlights it.
       */
      function myCheckIntersections() {
          if (!myPointCloud) return;

          // 1. Update the raycaster with the camera and mouse position
          myRaycaster.setFromCamera(myMousePosition, camera);

          // 2. Calculate intersections
          const myIntersects = myRaycaster.intersectObject(myPointCloud);

          // 3. Handle highlight
          if (myIntersects.length > 0) {
              // Intersects are sorted by distance, the first one is the closest
              const myIntersectedPoint = myIntersects[0].index;

              if (myHighlightedPoint !== myIntersectedPoint) {
                  // Restore color of previously highlighted point
                  if (myHighlightedPoint !== null) {
                      myRestorePointColor(myHighlightedPoint);
                  }

                  // Highlight the new point
                  myHighlightPointColor(myIntersectedPoint);
                  myHighlightedPoint = myIntersectedPoint;
              }
          } else {
              // No intersection, restore previous point color
              if (myHighlightedPoint !== null) {
                  myRestorePointColor(myHighlightedPoint);
                  myHighlightedPoint = null;
              }
          }
      }

      // --- ANIMATION AND UTILITY FUNCTIONS ---

      /**
       * The main animation loop.
       */
      function myAnimate() {
          requestAnimationFrame(myAnimate);

          // Check for mouse intersection (mouseover effect)
          myCheckIntersections();

          controls.update(); // Required for OrbitControls damping and auto-rotate
          renderer.render(scene, camera);
      }

      /**
       * Handles window resizing.
       */
      function myOnWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
      }

      // UI Update Functions
      function mySetAutoRotate(myChecked) { controls.autoRotate = myChecked; }
      
      function myUpdatePointSize(myEvent) { 
          const mySize = parseFloat(myEvent.target.value);
          document.getElementById('myPointSizeValue').textContent = mySize.toFixed(1); 
          if(myPointCloud) {
              myPointCloud.material.size = mySize;
              myPointCloud.material.needsUpdate = true;
          }
      }

      // Start the application
      window.onload = myInit;
    </script>
  </body>
</html>
