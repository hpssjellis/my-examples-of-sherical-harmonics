<!DOCTYPE html>
<html lang="en">
Â  <head>
Â  Â  <meta charset="UTF-8" />
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
Â  Â  <title>Minimal Static Point Cloud Viewer</title>
Â  Â  <style>
Â  Â  Â  /* Minimal inline CSS for layout and UI */
Â  Â  Â  body, html {
Â  Â  Â  Â  height: 100%; width: 100%; margin: 0; display: flex;
Â  Â  Â  Â  justify-content: center; align-items: center; overflow: hidden;
Â  Â  Â  Â  background-color: #333; font-family: sans-serif;
Â  Â  Â  }
Â  Â  Â  canvas { width: 100%; height: 100%; display: block; }
Â  Â  Â  #myUiContainer, #mySaveLoadContainer, #howto-container, #debug-info {
Â  Â  Â  Â  position: fixed; padding: 10px; background-color: rgba(255, 255, 255, 0.85);
Â  Â  Â  Â  border-radius: 8px; box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); color: #333;
Â  Â  Â  Â  font-size: 14px; z-index: 10;
Â  Â  Â  }
Â  Â  Â  #myUiContainer { top: 10px; left: 10px; }
Â  Â  Â  #mySaveLoadContainer { bottom: 10px; left: 10px; width: 280px; }
Â  Â  Â  #howto-container { bottom: 10px; right: 10px; width: 180px; }
Â  Â  Â  .my-button { padding: 5px 8px; margin: 3px 3px 3px 0; background-color: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer; }
Â  Â  Â  .my-button:hover { background-color: #0056b3; }
Â  Â  Â  #myPointDataTextarea { width: 95%; height: 60px; margin-top: 5px; padding: 5px; border: 1px solid #ccc; resize: vertical; font-family: monospace; font-size: 10px; }
Â  Â  Â  #myFileLoader { padding: 5px; background-color: #f7f7f7; border-radius: 4px; }
Â  Â  Â  .slider-value { font-weight: bold; }
Â  Â  </style>
Â  Â  Â  Â  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
Â  Â  Â  Â  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
Â  </head>
Â  <body>
Â  Â  Â  Â  <div id="myUiContainer">
Â  Â  Â  <h3>Settings</h3>
Â  Â  Â  <label>
Â  Â  Â  Â  <input type="checkbox" id="myAutoRotateCheckbox" checked
             onclick="mySetAutoRotate(this.checked)"> Auto Rotate
Â  Â  Â  </label>

Â  Â  Â  <div style="margin-top: 10px;">
Â  Â  Â  Â  <label for="myPointSizeSlider">Point Size:</label>
Â  Â  Â  Â  <input type="range" id="myPointSizeSlider" min="0.5" max="10" value="3" step="0.5"
             oninput="myUpdatePointSize(event)"/>
Â  Â  Â  Â  <span id="myPointSizeValue" class="slider-value">3.0</span>
Â  Â  Â  </div>
Â  Â  </div>


Â  Â  Â  Â  <div id="mySaveLoadContainer">
Â  Â  Â  Â  <b>Point Cloud Data (JSON)</b>
Â  Â  Â  Â  <div style="margin-top: 5px;">
Â  Â  Â  Â  Â  Â  <button class="my-button" onclick="mySaveToTextarea()">Save Current</button>
Â  Â  Â  Â  Â  Â  <button class="my-button" onclick="myLoadFromTextarea()">Load Textarea</button>
Â  Â  Â  Â  Â  Â  <button class="my-button" onclick="mySaveToFile()">Download File</button>
Â  Â  Â  Â  </div>
Â  Â  Â  Â  <textarea id="myPointDataTextarea" placeholder="Paste JSON point data here to load..."></textarea>
Â  Â  Â  Â  <div id="myStatusMessage" style="color: #007bff; font-weight: bold; margin-top: 5px;">Awaiting file load...</div>

Â  Â  Â  Â  <hr style="border: 0; height: 1px; background-color: #ccc; margin: 10px 0;">

Â  Â  Â  Â  Â  Â  Â  Â  <div id="myFileLoader">
Â  Â  Â  Â  Â  Â  Load from JSON File:
Â  Â  Â  Â  Â  Â  <input type="file" accept=".json" onchange="myLoadFromFile(event)" style="display: block; margin-top: 5px;">
Â  Â  Â  Â  </div>
Â  Â  </div>

Â  Â  Â  Â  <div id="howto-container">
Â  Â  Â  Â  <div> <b>Drag</b> to orbit the model </div>
Â  Â  Â  Â  <div> <b>Scroll</b> to zoom </div>
Â  Â  Â  Â  <div> <b>Mouseover</b> to highlight points </div>
Â  Â  </div>

Â  Â  Â  Â  <div id="debug-info" style="position: fixed; top: 10px; right: 10px; background: rgba(0,0,0,0.5); color: white; padding: 5px; border-radius: 4px;">
Â  Â  Â  <span id="error-reason">Loading 3D scene...</span>
Â  Â  </div>

Â  Â  Â  Â  <canvas id="myFluidCanvas"></canvas>

Â  Â  <script>
Â  Â  Â  // Declare Three.js global variables
Â  Â  Â  let scene, camera, renderer, myPointCloud, controls;

Â  Â  Â  // --- MOUSE INTERACTION (RAYCASTING) VARIABLES ---
Â  Â  Â  let myRaycaster;
Â  Â  Â  let myMousePosition = new THREE.Vector2();
Â  Â  Â  let myHighlightedPoint = null;
Â  Â  Â  let myDefaultColor = new THREE.Color(0xffffff); // White
Â  Â  Â  let myHighlightColor = new THREE.Color(0xff0000); // Red

Â  Â  Â  // DOM Elements
Â  Â  Â  const myDebugInfo = document.getElementById('debug-info');
Â  Â  Â  const myPointDataTextarea = document.getElementById('myPointDataTextarea');
Â  Â  Â  const myStatusMessage = document.getElementById('myStatusMessage');


Â  Â  Â  /**
Â  Â  Â  Â * Initializes the Three.js scene.
Â  Â  Â  Â */
Â  Â  Â  function myInit() {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  console.log("--- Scene Initialization Start ---");
Â  Â  Â  Â  Â  Â  Â  myDebugInfo.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  myDebugInfo.querySelector('span').textContent = 'Initializing 3D scene...';

Â  Â  Â  Â  Â  Â  Â  const myCanvas = document.getElementById('myFluidCanvas');
Â  Â  Â  Â  Â  Â  Â  renderer = new THREE.WebGLRenderer({ canvas: myCanvas, antialias: true });
Â  Â  Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  Â  Â  Â  Â  renderer.setPixelRatio(window.devicePixelRatio);
              
              // ðŸ’¡ DEBUG LOG: Confirm renderer size
              console.log(`Renderer Size: ${window.innerWidth}x${window.innerHeight}, Pixel Ratio: ${window.devicePixelRatio}`);

Â  Â  Â  Â  Â  Â  Â  scene = new THREE.Scene();
Â  Â  Â  Â  Â  Â  Â  scene.background = new THREE.Color(0x333333);
Â  Â  Â  Â  Â  Â  Â  camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
Â  Â  Â  Â  Â  Â  Â  camera.position.z = 150;
              
              // ðŸ’¡ DEBUG LOG: Confirm camera position
              console.log(`Camera Position: Z=${camera.position.z}`);

Â  Â  Â  Â  Â  Â  Â  // Initialize controls BEFORE creating the point cloud so controls.target can be set
              controls = new THREE.OrbitControls(camera, renderer.domElement);
Â  Â  Â  Â  Â  Â  Â  controls.autoRotate = document.getElementById('myAutoRotateCheckbox').checked;
Â  Â  Â  Â  Â  Â  Â  controls.enableDamping = true;
Â  Â  Â  Â  Â  Â  Â  controls.dampingFactor = 0.05;
              
Â  Â  Â  Â  Â  Â  Â  // --- CALL WITH NO ARGUMENTS TO CREATE DEFAULT CUBE ---
Â  Â  Â  Â  Â  Â  Â  myCreatePointCloud();


Â  Â  Â  Â  Â  Â  Â  myRaycaster = new THREE.Raycaster();
Â  Â  Â  Â  Â  Â  Â  myRaycaster.params.Points.threshold = 20; 

Â  Â  Â  Â  Â  Â  Â  window.addEventListener('mousemove', (myEvent) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  myMousePosition.x = (myEvent.clientX / window.innerWidth) * 2 - 1;
Â  Â  Â  Â  Â  Â  Â  Â  Â  myMousePosition.y = -(myEvent.clientY / window.innerHeight) * 2 + 1;
Â  Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  Â  window.onresize = myOnWindowResize;

Â  Â  Â  Â  Â  Â  Â  myDebugInfo.style.display = 'none';
              console.log("--- Scene Initialization Complete ---");
Â  Â  Â  Â  Â  Â  Â  myAnimate();
Â  Â  Â  Â  Â  } catch (error) {
Â  Â  Â  Â  Â  Â  Â  console.error("Error during initialization:", error);
Â  Â  Â  Â  Â  Â  Â  myDebugInfo.style.display = 'block';
Â  Â  Â  Â  Â  Â  Â  myDebugInfo.querySelector('span').textContent = `Error: ${error.message}.`;
Â  Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  /**
Â  Â  Â  Â * Creates or recreates the point cloud object.
       * If no array is provided, it defaults to a simple 3x3x3 grid (27 points).
Â  Â  Â  Â */
Â  Â  Â  function myCreatePointCloud(myPositionsArray = null) {
Â  Â  Â  Â  Â  // Dispose of old point cloud object
Â  Â  Â  Â  Â  if (myPointCloud) {
              console.log("Removing previous point cloud...");
Â  Â  Â  Â  Â  Â  Â  scene.remove(myPointCloud);
Â  Â  Â  Â  Â  Â  Â  myPointCloud.geometry.dispose();
Â  Â  Â  Â  Â  Â  Â  myPointCloud.material.dispose();
Â  Â  Â  Â  Â  }

          let myGeometry = new THREE.BufferGeometry();
          let myFinalPositions;
          let myVertexCount;

          if (myPositionsArray && myPositionsArray.length > 0) {
              // Use loaded data
              myFinalPositions = new Float32Array(myPositionsArray);
              myVertexCount = myFinalPositions.length / 3;
              console.log(`Loading custom data with ${myVertexCount} vertices.`);
          } else {
              // Create default 3x3x3 cube (27 points)
              const myCubeSize = 100; 
              myVertexCount = 27;
              myFinalPositions = new Float32Array(myVertexCount * 3);
              let index = 0;
              for (let x = -1; x <= 1; x++) {
                  for (let y = -1; y <= 1; y++) {
                      for (let z = -1; z <= 1; z++) {
                          myFinalPositions[index++] = x * myCubeSize;
                          myFinalPositions[index++] = y * myCubeSize;
                          myFinalPositions[index++] = z * myCubeSize;
                      }
                  }
              }
              myStatusMessage.textContent = 'Loaded default 27-point cube.';
              // ðŸ’¡ DEBUG LOG: Confirm default geometry data
              console.log(`Created default ${myVertexCount}-point cube. Cube scale: ${myCubeSize}.`);
              console.log(`First point position (X, Y, Z): ${myFinalPositions[0]}, ${myFinalPositions[1]}, ${myFinalPositions[2]}`);
              console.log(`Last point position (X, Y, Z): ${myFinalPositions[myFinalPositions.length-3]}, ${myFinalPositions[myFinalPositions.length-2]}, ${myFinalPositions[myFinalPositions.length-1]}`);
          }

          myGeometry.setAttribute('position', new THREE.BufferAttribute(myFinalPositions, 3));


Â  Â  Â  Â  Â  // Add vertex colors (required for highlighting)
Â  Â  Â  Â  Â  const myColorArray = new Float32Array(myVertexCount * 3);
Â  Â  Â  Â  Â  for (let i = 0; i < myColorArray.length; i += 3) {
Â  Â  Â  Â  Â  Â  Â  myColorArray[i] = myDefaultColor.r;
Â  Â  Â  Â  Â  Â  Â  myColorArray[i + 1] = myDefaultColor.g;
Â  Â  Â  Â  Â  Â  Â  myColorArray[i + 2] = myDefaultColor.b;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  myGeometry.setAttribute('color', new THREE.BufferAttribute(myColorArray, 3));


Â  Â  Â  Â  Â  // Create Points Material, reading the slider value directly
          const myPointSize = parseFloat(document.getElementById('myPointSizeSlider').value);
Â  Â  Â  Â  Â  const myPointsMaterial = new THREE.PointsMaterial({
              vertexColors: true,
Â  Â  Â  Â  Â  Â  Â  size: myPointSize,
              sizeAttenuation: true
Â  Â  Â  Â  Â  });
          
          // ðŸ’¡ DEBUG LOG: Confirm point size
          console.log(`Points Material Size: ${myPointSize}`);

Â  Â  Â  Â  Â  myPointCloud = new THREE.Points(myGeometry, myPointsMaterial);
Â  Â  Â  Â  Â  scene.add(myPointCloud);

Â  Â  Â  Â  Â  myHighlightedPoint = null;

          // Center the view on the new object
          if (myPointCloud.geometry.boundingBox === null) myPointCloud.geometry.computeBoundingBox();
          const myCenter = new THREE.Vector3();
          myPointCloud.geometry.boundingBox.getCenter(myCenter);
          controls.target.copy(myCenter);
          controls.update(); 
          // ðŸ’¡ DEBUG LOG: Confirm controls target
          console.log(`Controls Target (Center): ${myCenter.x.toFixed(2)}, ${myCenter.y.toFixed(2)}, ${myCenter.z.toFixed(2)}`);
Â  Â  Â  }


Â  Â  Â  /**
Â  Â  Â  Â * Loads point cloud positions by replacing the current geometry.
Â  Â  Â  Â */
Â  Â  Â  function myUpdatePointCloudPositions(myNewPositionsArray) {
Â  Â  Â  Â  Â  myCreatePointCloud(myNewPositionsArray);
          myStatusMessage.textContent = `Loaded ${myNewPositionsArray.length / 3} vertices successfully.`;
Â  Â  Â  }

Â  Â  Â  // ... (mySaveToTextarea, myLoadFromTextarea, myLoadFromFile, mySaveToFile functions are unchanged)

Â  Â  Â  /**
Â  Â  Â  Â * Saves the current point cloud data to the textarea.
Â  Â  Â  Â */
Â  Â  Â  function mySaveToTextarea() {
Â  Â  Â  Â  Â  if (!myPointCloud) return;

Â  Â  Â  Â  Â  const myPositions = myPointCloud.geometry.attributes.position.array;
Â  Â  Â  Â  Â  const myPositionsArray = Array.from(myPositions);

Â  Â  Â  Â  Â  const mySaveData = {
Â  Â  Â  Â  Â  Â  Â  metadata: "Static Point Cloud Positions (X, Y, Z coordinates)",
Â  Â  Â  Â  Â  Â  Â  vertexCount: myPositions.length / 3,
Â  Â  Â  Â  Â  Â  Â  segments: { width: 32, height: 32 },
Â  Â  Â  Â  Â  Â  Â  positions: myPositionsArray
Â  Â  Â  Â  Â  };

Â  Â  Â  Â  Â  // Use JSON.stringify for clean, standard JSON output
Â  Â  Â  Â  Â  myPointDataTextarea.value = JSON.stringify(mySaveData, null, 2);
Â  Â  Â  Â  Â  myStatusMessage.textContent = `Saved ${myPositions.length / 3} vertices to textarea.`;
Â  Â  Â  }

Â  Â  Â  /**
Â  Â  Â  Â * Loads point cloud data from the textarea (main processing logic).
Â  Â  Â  Â */
Â  Â  Â  function myLoadFromTextarea() {
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  const myJsonString = myPointDataTextarea.value.trim();
Â  Â  Â  Â  Â  Â  Â  if (!myJsonString) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  myStatusMessage.textContent = 'Error: Textarea is empty.';
Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  const myLoadedData = JSON.parse(myJsonString);
Â  Â  Â  Â  Â  Â  Â  const myNewPositionsArray = myLoadedData.positions;

Â  Â  Â  Â  Â  Â  Â  if (!Array.isArray(myNewPositionsArray) || myNewPositionsArray.length % 3 !== 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  myStatusMessage.textContent = 'Error: Loaded data structure is invalid.';
Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  myUpdatePointCloudPositions(myNewPositionsArray);

Â  Â  Â  Â  Â  } catch (myError) {
Â  Â  Â  Â  Â  Â  Â  myStatusMessage.textContent = `Error loading data: ${myError.message}`;
Â  Â  Â  Â  Â  Â  Â  console.error(myError);
Â  Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  /**
Â  Â  Â  Â * Loads a JSON file selected by the user (using async/await).
Â  Â  Â  Â */
Â  Â  Â  async function myLoadFromFile(myEvent) {
Â  Â  Â  Â  Â  const myFile = myEvent.target.files[0];
Â  Â  Â  Â  Â  if (!myFile) {
Â  Â  Â  Â  Â  Â  Â  myStatusMessage.textContent = 'No file selected.';
Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  myStatusMessage.textContent = `Reading file: ${myFile.name}...`;
Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  const myFileText = await new Promise((resolve, reject) => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  const myReader = new FileReader();
Â  Â  Â  Â  Â  Â  Â  Â  Â  myReader.onload = () => resolve(myReader.result);
Â  Â  Â  Â  Â  Â  Â  Â  Â  myReader.onerror = () => reject(new Error('Failed to read file.'));
Â  Â  Â  Â  Â  Â  Â  Â  Â  myReader.readAsText(myFile);
Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  myPointDataTextarea.value = myFileText;
Â  Â  Â  Â  Â  Â  Â  myLoadFromTextarea();
Â  Â  Â  Â  Â  Â  Â  myEvent.target.value = '';
Â  Â  Â  Â  Â  } catch (myError) {
Â  Â  Â  Â  Â  Â  Â  myStatusMessage.textContent = `Error reading file: ${myError.message}`;
Â  Â  Â  Â  Â  Â  Â  console.error(myError);
Â  Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  /**
Â  Â  Â  Â * Downloads the current point cloud data as a JSON file.
Â  Â  Â  Â */
Â  Â  Â  function mySaveToFile() {
Â  Â  Â  Â  Â  mySaveToTextarea();
Â  Â  Â  Â  Â  const myJsonString = myPointDataTextarea.value;
Â  Â  Â  Â  Â  const myBlob = new Blob([myJsonString], { type: 'application/json' });
Â  Â  Â  Â  Â  const myUrl = URL.createObjectURL(myBlob);
Â  Â  Â  Â  Â  const myLink = document.createElement('a');
Â  Â  Â  Â  Â  myLink.href = myUrl;
Â  Â  Â  Â  Â  myLink.download = `pointcloud-data-${Date.now()}.json`;
Â  Â  Â  Â  Â  document.body.appendChild(myLink);
Â  Â  Â  Â  Â  myLink.click();
Â  Â  Â  Â  Â  document.body.removeChild(myLink);
Â  Â  Â  Â  Â  myStatusMessage.textContent = 'Point Cloud downloaded as JSON file.';
Â  Â  Â  Â  Â  URL.revokeObjectURL(myUrl);
Â  Â  Â  }

Â  Â  Â  // --- MOUSE HIGHLIGHTING FUNCTIONS (Unchanged) ---

Â  Â  Â  function myHighlightPointColor(myIndex) {
Â  Â  Â  Â  Â  const myColors = myPointCloud.geometry.attributes.color;
Â  Â  Â  Â  Â  if (!myColors) return;
Â  Â  Â  Â  Â  myColors.setXYZ(myIndex, myHighlightColor.r, myHighlightColor.g, myHighlightColor.b);
Â  Â  Â  Â  Â  myColors.needsUpdate = true;
Â  Â  Â  }

Â  Â  Â  function myRestorePointColor(myIndex) {
Â  Â  Â  Â  Â  const myColors = myPointCloud.geometry.attributes.color;
Â  Â  Â  Â  Â  myColors.setXYZ(myIndex, myDefaultColor.r, myDefaultColor.g, myDefaultColor.b);
Â  Â  Â  Â  Â  myColors.needsUpdate = true;
Â  Â  Â  }

Â  Â  Â  function myCheckIntersections() {
Â  Â  Â  Â  Â  if (!myPointCloud) return;
Â  Â  Â  Â  Â  myRaycaster.setFromCamera(myMousePosition, camera);
Â  Â  Â  Â  Â  const myIntersects = myRaycaster.intersectObject(myPointCloud);

Â  Â  Â  Â  Â  if (myIntersects.length > 0) {
Â  Â  Â  Â  Â  Â  Â  const myIntersectedPoint = myIntersects[0].index;
Â  Â  Â  Â  Â  Â  Â  if (myHighlightedPoint !== myIntersectedPoint) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  if (myHighlightedPoint !== null) { myRestorePointColor(myHighlightedPoint); }
Â  Â  Â  Â  Â  Â  Â  Â  Â  myHighlightPointColor(myIntersectedPoint);
Â  Â  Â  Â  Â  Â  Â  Â  Â  myHighlightedPoint = myIntersectedPoint;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  if (myHighlightedPoint !== null) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  myRestorePointColor(myHighlightedPoint);
Â  Â  Â  Â  Â  Â  Â  Â  Â  myHighlightedPoint = null;
Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  }

Â  Â  Â  // --- ANIMATION AND UTILITY FUNCTIONS (Unchanged) ---

Â  Â  Â  function myAnimate() {
Â  Â  Â  Â  Â  requestAnimationFrame(myAnimate);
Â  Â  Â  Â  Â  myCheckIntersections();
Â  Â  Â  Â  Â  controls.update();
Â  Â  Â  Â  Â  renderer.render(scene, camera);
Â  Â  Â  }

Â  Â  Â  function myOnWindowResize() {
Â  Â  Â  Â  Â  camera.aspect = window.innerWidth / window.innerHeight;
Â  Â  Â  Â  Â  camera.updateProjectionMatrix();
Â  Â  Â  Â  Â  renderer.setSize(window.innerWidth, window.innerHeight);
Â  Â  Â  }

Â  Â  Â  // UI Update Functions (Unchanged)
Â  Â  Â  function mySetAutoRotate(myChecked) { controls.autoRotate = myChecked; }

      /**
       * New function to handle setting the point size on the material.
       */
      function mySetPointSize(mySize) {
          document.getElementById('myPointSizeValue').textContent = mySize.toFixed(1);
          if(myPointCloud && myPointCloud.material) {
              myPointCloud.material.size = mySize;
              myPointCloud.material.needsUpdate = true;
          }
      }

Â  Â  Â  /**
       * Event handler for the slider input (reads value and calls setter).
       */
Â  Â  Â  function myUpdatePointSize(myEvent) {
Â  Â  Â  Â  Â  const mySize = parseFloat(myEvent.target.value);
Â  Â  Â  Â  Â  mySetPointSize(mySize);
Â  Â  Â  }

Â  Â  Â  // Start the application
Â  Â  Â  window.onload = myInit;
Â  Â  </script>
Â  </body>
</html>
